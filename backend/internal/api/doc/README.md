## Clean Architecture

This project follows the principles of Clean Architecture, 
ensuring that the core business logic is independent of external frameworks, databases, and other I/O components. 
The architecture promotes separation of concerns, making the system more maintainable and scalable.

<div align="center">
  <img src="clean_architecture.png" alt="The Clean Architecture">
</div>

> Chapter 22, Figure 22.1: The clean architecture. This image instance was copied from Uncle Bobâ€™s article [here](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html).

## Directory Structure
```bash
.
â”œâ”€â”€ domain
â”‚   â”œâ”€â”€ model # Entities
â”‚   â””â”€â”€ repository # Data Access Interface<I(Interface)>
â”œâ”€â”€ infra
â”‚   â””â”€â”€ repository # Data Access
â”œâ”€â”€ injector
â”‚   â””â”€â”€ wire.go
â”œâ”€â”€ interfaces
â”‚   â””â”€â”€ controller # Controller
â””â”€â”€ usecase
    â”œâ”€â”€ dto # DTO (DataTransferObject)
    â”‚   â”œâ”€â”€ input # Input Data<DS(Data Structure)>
    â”‚   â””â”€â”€ output # Output Data<DS>
    â””â”€â”€ interactor.go 
    # Usecase Interactor:ğ‘ˆ
    # InputBoundary:ğ¼ğµ
    # OutputBoundary:ğ‘‚ğµ
    # ğ‘ˆ âˆˆ Impl(ğ¼ğµ âˆª ğ‘‚ğµ)
```

### Corresponding Class Diagrams

<div align="center">
  <img src="clean_boundary.jpg" alt="Clean Boundary">
</div>

> Chapter 22, Figure 22.2: A typical scenario for a web-based Java system utilizing a database

## Layer Overview

### Entities (domain)
Located in the `domain` directory, the entities represent the core business objects and rules. 
This layer is independent of any other layers and frameworks.

- **Model**: Contains the business entities (e.g., message.go). 
- **Repository**: Contains abstract interfaces for data access (e.g., IMessageRepository).  
These interfaces are defined here to prevent the `usecase` layer from depending on the interface adapters.

> [!NOTE]
> Typically, `repository` is part of the interface adapters layer as `gateways`.  
> However, to avoid the `usecase` layer depending on the interface adapters, we define repository interfaces in the `domain` layer.

#### Dependencies
- No dependencies

### Use Cases (usecase)

Located in the `usecase` directory, this layer contains the application-specific business rules.  
It orchestrates the flow of data to and from the entities and leverages the interfaces defined in the `domain` layer.

- **Interactor**: Contains the business logic that interacts with the entities.
- **DTO**: Data Transfer Objects used for input and output (e.g., input and output directories).

#### Dependencies
- domain
- usecase

### Interface Adapters (interfaces / infra)

Located in the `interfaces` and `infra` directory,  
this layer converts data from the format most convenient for the use cases and entities to the format most convenient for external agents such as databases and the web.

- **Controllers**: Handle the HTTP requests and responses, interacting with the use cases.
- **Model**: Contains database-specific models generated by tools like SQLBoiler (e.g., messages.go). These models represent the structure of the data as it is stored in the database and are used by the repository implementations to interact with the database.
- **Repository**: Implements the repository interfaces defined in the use cases layer using specific frameworks (e.g., SQLBoiler for database operations). The repository layer abstracts the data access logic and provides a clean API for the use cases to interact with the data source.

#### Dependencies
- domain
- usecase

### Frameworks & Driver

Located in the infra directory, this layer contains the framework and driver code, such as database implementations, external APIs, and web frameworks.

### Dependency Injection (injector) 

Located in the `injector` directory, this layer manages dependency injection configurations.  
This directory is unrelated to the clean architecture.

- **Wire**: Configures and initializes the dependencies using Google Wire (e.g., wire.go).
